# ================== FUNCIONALIDADES AVAN√áADAS PARA DR_C ==================
# Arquivo: advanced_features.py

import plotly.express as px
import plotly.graph_objects as go
import pandas as pd
from wordcloud import WordCloud
import matplotlib.pyplot as plt
from collections import Counter
import streamlit as st

def create_biodiversity_metrics_dashboard(meta):
    """Cria dashboard de m√©tricas da base de conhecimento"""
    if not meta:
        return
    
    st.subheader("üìä An√°lise da Base de Conhecimento")
    
    # M√©tricas b√°sicas
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("Total de Chunks", len(meta))
    
    with col2:
        sources = [m.get('source', 'Unknown') for m in meta]
        unique_sources = len(set(sources))
        st.metric("Documentos", unique_sources)
    
    with col3:
        total_chars = sum(len(m.get('content', '')) for m in meta)
        st.metric("Caracteres Totais", f"{total_chars:,}")
    
    with col4:
        avg_chunk_size = total_chars / len(meta) if meta else 0
        st.metric("Tamanho M√©dio/Chunk", f"{avg_chunk_size:.0f}")
    
    # Distribui√ß√£o por fonte
    if len(set(sources)) > 1:
        source_counts = Counter(sources)
        df_sources = pd.DataFrame([
            {"Documento": doc, "Chunks": count} 
            for doc, count in source_counts.items()
        ])
        
        fig_pie = px.pie(
            df_sources, 
            values='Chunks', 
            names='Documento',
            title="Distribui√ß√£o de Conte√∫do por Documento"
        )
        st.plotly_chart(fig_pie, use_container_width=True)

def generate_topic_analysis(meta):
    """An√°lise de t√≥picos na base de conhecimento"""
    if not meta:
        return
    
    st.subheader("üîç An√°lise de T√≥picos")
    
    # Palavras-chave relacionadas √† biodiversidade
    biodiversity_keywords = {
        'floresta': ['floresta', '√°rvore', '√°rvores', 'mata', 'vegeta√ß√£o'],
        'biodiversidade': ['biodiversidade', 'esp√©cie', 'esp√©cies', 'fauna', 'flora'],
        'conserva√ß√£o': ['conserva√ß√£o', 'preserva√ß√£o', 'sustent√°vel', 'manejo'],
        'economia': ['economia', 'econ√¥mico', 'lucro', 'rentabilidade', 'viabilidade'],
        'amaz√¥nia': ['amaz√¥nia', 'amaz√¥nica', 'regi√£o'],
        'vis√£o_estrat√©gica': ['longo prazo', 'futuro', 'estrat√©gia', 'planejamento'],
        'storytelling': ['hist√≥ria', 'exemplo', 'caso', 'experi√™ncia']
    }
    
    # Analisa respostas
    all_answers = ' '.join([chat.get('answer', '').lower() for chat in chat_history])
    
    persona_scores = {}
    for aspect, keywords in persona_indicators.items():
        score = sum(all_answers.count(keyword) for keyword in keywords)
        persona_scores[aspect] = score
    
    if persona_scores:
        df_persona = pd.DataFrame([
            {"Aspecto": aspect.replace('_', ' ').title(), "Pontua√ß√£o": score}
            for aspect, score in persona_scores.items()
        ])
        
        fig_radar = go.Figure()
        
        fig_radar.add_trace(go.Scatterpolar(
            r=list(persona_scores.values()),
            theta=list(df_persona['Aspecto']),
            fill='toself',
            name='Dr_C Persona',
            line_color='green'
        ))
        
        fig_radar.update_layout(
            polar=dict(
                radialaxis=dict(
                    visible=True,
                    range=[0, max(persona_scores.values()) if persona_scores.values() else 1]
                )),
            showlegend=True,
            title="An√°lise da Consist√™ncia da Persona Dr_C"
        )
        
        st.plotly_chart(fig_radar, use_container_width=True)

def create_semantic_search_suggestions(meta, current_query=""):
    """Sugere perguntas relacionadas baseadas no conte√∫do dispon√≠vel"""
    if not meta:
        return []
    
    # Extrai conceitos-chave do conte√∫do
    key_concepts = [
        "Como a floresta pode gerar lucro sustent√°vel?",
        "Qual a import√¢ncia do manejo sustent√°vel?",
        "Como cuidar das comunidades amaz√¥nicas?",
        "Quais s√£o os projetos do Dr_C na Amaz√¥nia?",
        "Como a tecnologia pode ajudar na conserva√ß√£o?",
        "Qual o valor econ√¥mico da biodiversidade?",
        "Como funciona o projeto Fruits of the Amazon?",
        "Que esp√©cies foram descobertas pelo Dr_C?",
        "Como reverter √°reas degradadas?",
        "Qual a rela√ß√£o entre conserva√ß√£o e rentabilidade?"
    ]
    
    return key_concepts

def add_feedback_system():
    """Sistema de feedback para melhorar as respostas"""
    st.subheader("üìù Feedback sobre Dr_C")
    
    with st.form("feedback_form"):
        rating = st.slider("Como voc√™ avalia as respostas do Dr_C?", 1, 5, 3)
        
        feedback_type = st.selectbox(
            "Tipo de feedback:",
            ["Geral", "Precis√£o t√©cnica", "Tom de resposta", "Relev√¢ncia", "Sugest√£o de melhoria"]
        )
        
        feedback_text = st.text_area(
            "Seu feedback (opcional):",
            placeholder="Compartilhe sua experi√™ncia ou sugest√µes..."
        )
        
        submitted = st.form_submit_button("Enviar Feedback")
        
        if submitted:
            # Aqui voc√™ poderia salvar o feedback em um banco de dados
            st.success("Obrigado pelo seu feedback! Ele nos ajuda a melhorar o Dr_C.")
            
            # Exibe m√©tricas de feedback (simulado)
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Avalia√ß√£o M√©dia", "4.2/5.0")
            with col2:
                st.metric("Total de Feedbacks", "47")
            with col3:
                st.metric("Satisfa√ß√£o", "89%")

def create_educational_mode():
    """Modo educacional com explica√ß√µes detalhadas"""
    st.subheader("üéì Modo Educacional")
    
    educational_topics = {
        "Biodiversidade": {
            "conceito": "A variedade de vida em todas as suas formas e n√≠veis de organiza√ß√£o",
            "importancia": "Essencial para estabilidade dos ecossistemas e bem-estar humano",
            "ameacas": "Desmatamento, mudan√ßas clim√°ticas, polui√ß√£o, urbaniza√ß√£o"
        },
        "Manejo Sustent√°vel": {
            "conceito": "Uso dos recursos naturais de forma que se mantenham para gera√ß√µes futuras",
            "principios": "Planejamento, monitoramento, adapta√ß√£o, participa√ß√£o comunit√°ria",
            "beneficios": "Conserva√ß√£o + desenvolvimento econ√¥mico + bem-estar social"
        },
        "Economia Verde": {
            "conceito": "Modelo econ√¥mico que considera o capital natural como fator de produ√ß√£o",
            "exemplos": "Pagamento por servi√ßos ambientais, ecoturismo, produtos sustent√°veis",
            "desafios": "Mensura√ß√£o de valor, pol√≠ticas p√∫blicas, mudan√ßa cultural"
        }
    }
    
    selected_topic = st.selectbox(
        "Escolha um t√≥pico para aprender:",
        list(educational_topics.keys())
    )
    
    if selected_topic:
        topic_info = educational_topics[selected_topic]
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown(f"**Conceito:**")
            st.write(topic_info.get("conceito", ""))
            
            if "principios" in topic_info:
                st.markdown(f"**Princ√≠pios:**")
                st.write(topic_info["principios"])
            elif "importancia" in topic_info:
                st.markdown(f"**Import√¢ncia:**")
                st.write(topic_info["importancia"])
        
        with col2:
            if "exemplos" in topic_info:
                st.markdown(f"**Exemplos:**")
                st.write(topic_info["exemplos"])
            elif "beneficios" in topic_info:
                st.markdown(f"**Benef√≠cios:**")
                st.write(topic_info["beneficios"])
            
            if "ameacas" in topic_info:
                st.markdown(f"**Principais Amea√ßas:**")
                st.write(topic_info["ameacas"])
            elif "desafios" in topic_info:
                st.markdown(f"**Desafios:**")
                st.write(topic_info["desafios"])

def create_interactive_timeline():
    """Timeline interativa da jornada do Dr_C"""
    st.subheader("üìÖ Jornada do Dr_C")
    
    timeline_events = [
        {"ano": 1990, "evento": "In√≠cio dos estudos na Amaz√¥nia", "tipo": "educa√ß√£o"},
        {"ano": 2000, "evento": "Primeiros investimentos em agroneg√≥cios sustent√°veis", "tipo": "neg√≥cios"},
        {"ano": 2010, "evento": "Cria√ß√£o do projeto Fruits of the Amazon", "tipo": "conserva√ß√£o"},
        {"ano": 2015, "evento": "Parceria com Royal Botanic Gardens, Kew", "tipo": "pesquisa"},
        {"ano": 2020, "evento": "Descoberta de 13 novas esp√©cies", "tipo": "ci√™ncia"},
        {"ano": 2023, "evento": "Desenvolvimento do Dr_C AI", "tipo": "tecnologia"},
        {"ano": 2024, "evento": "Lan√ßamento do projeto ZYMZON", "tipo": "inova√ß√£o"}
    ]
    
    df_timeline = pd.DataFrame(timeline_events)
    
    fig_timeline = px.scatter(
        df_timeline,
        x='ano',
        y=[1]*len(df_timeline),
        color='tipo',
        size=[10]*len(df_timeline),
        hover_data=['evento'],
        title="Linha do Tempo - Marcos na Carreira do Dr_C"
    )
    
    fig_timeline.update_layout(
        showlegend=True,
        yaxis_visible=False,
        height=300
    )
    
    st.plotly_chart(fig_timeline, use_container_width=True)
    
    # Detalhes do evento selecionado
    selected_year = st.selectbox("Explore um marco:", df_timeline['ano'].tolist())
    
    if selected_year:
        event = df_timeline[df_timeline['ano'] == selected_year].iloc[0]
        st.info(f"**{event['ano']}:** {event['evento']}")

def create_impact_calculator():
    """Calculadora de impacto ambiental"""
    st.subheader("üå± Calculadora de Impacto")
    
    st.write("Calcule o impacto potencial de projetos de reflorestamento:")
    
    col1, col2 = st.columns(2)
    
    with col1:
        area_hectares = st.number_input("√Årea para reflorestamento (hectares):", min_value=0.1, value=10.0)
        tree_density = st.number_input("Densidade de √°rvores (por hectare):", min_value=100, value=500)
        
    with col2:
        co2_per_tree_year = st.number_input("CO‚ÇÇ absorvido por √°rvore/ano (kg):", min_value=1.0, value=22.0)
        project_years = st.number_input("Dura√ß√£o do projeto (anos):", min_value=1, value=20)
    
    if st.button("Calcular Impacto"):
        total_trees = area_hectares * tree_density
        annual_co2 = total_trees * co2_per_tree_year
        total_co2 = annual_co2 * project_years
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("√Årvores Plantadas", f"{total_trees:,.0f}")
        
        with col2:
            st.metric("CO‚ÇÇ/Ano", f"{annual_co2:,.0f} kg")
        
        with col3:
            st.metric("CO‚ÇÇ Total", f"{total_co2:,.0f} kg")
        
        with col4:
            equivalent_cars = total_co2 / 4600  # m√©dia anual de emiss√£o por carro
            st.metric("Equiv. Carros/Ano", f"{equivalent_cars:.0f}")
        
        # Visualiza√ß√£o do crescimento
        years = list(range(1, project_years + 1))
        co2_cumulative = [annual_co2 * year for year in years]
        
        df_growth = pd.DataFrame({
            'Ano': years,
            'CO‚ÇÇ Acumulado (kg)': co2_cumulative
        })
        
        fig_growth = px.area(
            df_growth,
            x='Ano',
            y='CO‚ÇÇ Acumulado (kg)',
            title="Proje√ß√£o de Absor√ß√£o de CO‚ÇÇ ao Longo do Tempo"
        )
        
        st.plotly_chart(fig_growth, use_container_width=True)

# ================== FUNCIONALIDADES DE INTEGRA√á√ÉO ==================

def create_api_documentation():
    """Documenta√ß√£o para integra√ß√£o via API"""
    st.subheader("üîå Integra√ß√£o e API")
    
    st.markdown("""
    ### Como Integrar o Dr_C em Outros Sistemas
    
    #### 1. Via Streamlit Components
    ```python
    import streamlit as st
    from dr_c_avatar import DrCAvatarComponent
    
    # Integrar em outra aplica√ß√£o Streamlit
    response = DrCAvatarComponent.ask_question("Como preservar a biodiversidade?")
    ```
    
    #### 2. Via REST API (Exemplo)
    ```python
    import requests
    
    response = requests.post('http://localhost:8501/api/ask', 
                           json={'question': 'Valor econ√¥mico da floresta?'})
    answer = response.json()['answer']
    ```
    
    #### 3. Webhook para Notifica√ß√µes
    ```json
    {
        "event": "new_question",
        "timestamp": "2024-01-15T10:30:00Z",
        "question": "Como plantar √°rvores nativas?",
        "confidence": 0.85
    }
    ```
    """)

def create_admin_panel():
    """Painel administrativo para gest√£o do sistema"""
    st.subheader("‚öôÔ∏è Painel Administrativo")
    
    # Simula√ß√£o de autentica√ß√£o
    if st.checkbox("Modo Administrador (Demo)"):
        
        tab1, tab2, tab3 = st.tabs(["Configura√ß√µes", "Logs", "Usu√°rios"])
        
        with tab1:
            st.write("**Configura√ß√µes do Sistema:**")
            
            col1, col2 = st.columns(2)
            
            with col1:
                confidence_threshold = st.slider("Limite de Confian√ßa", 0.0, 1.0, 0.7)
                max_sources = st.number_input("M√°ximo de Fontes", 1, 10, 5)
                
            with col2:
                response_style = st.selectbox("Estilo de Resposta", 
                                            ["Formal", "Conversacional", "T√©cnico"])
                enable_analytics = st.checkbox("Habilitar Analytics", True)
            
            if st.button("Salvar Configura√ß√µes"):
                st.success("Configura√ß√µes salvas com sucesso!")
        
        with tab2:
            st.write("**Logs do Sistema:**")
            
            # Simula√ß√£o de logs
            sample_logs = [
                {"timestamp": "2024-01-15 10:30:00", "level": "INFO", "message": "Nova pergunta processada"},
                {"timestamp": "2024-01-15 10:25:00", "level": "DEBUG", "message": "Busca sem√¢ntica executada"},
                {"timestamp": "2024-01-15 10:20:00", "level": "WARNING", "message": "Baixa confian√ßa na resposta"},
            ]
            
            for log in sample_logs:
                color = {"INFO": "üü¢", "DEBUG": "üîµ", "WARNING": "üü°", "ERROR": "üî¥"}
                st.write(f"{color.get(log['level'], '‚ö™')} {log['timestamp']} - {log['message']}")
        
        with tab3:
            st.write("**Gest√£o de Usu√°rios:**")
            
            # Simula√ß√£o de dados de usu√°rios
            users_data = {
                "Usu√°rio": ["usuario1@email.com", "usuario2@email.com", "admin@email.com"],
                "Perguntas": [23, 45, 12],
                "√öltima Atividade": ["2024-01-15", "2024-01-14", "2024-01-15"],
                "Status": ["Ativo", "Ativo", "Admin"]
            }
            
            df_users = pd.DataFrame(users_data)
            st.dataframe(df_users, use_container_width=True)

# ================== FUN√á√ÉO PRINCIPAL PARA INTEGRA√á√ÉO ==================

def render_advanced_features(meta=None, chat_history=None):
    """Fun√ß√£o principal para renderizar todas as funcionalidades avan√ßadas"""
    
    st.sidebar.markdown("---")
    st.sidebar.markdown("### üöÄ Funcionalidades Avan√ßadas")
    
    features = {
        "üìä Analytics": "analytics",
        "üéì Modo Educacional": "educational",
        "üìÖ Timeline": "timeline", 
        "üå± Calculadora de Impacto": "calculator",
        "üìù Feedback": "feedback",
        "üîå Integra√ß√£o": "api",
        "‚öôÔ∏è Admin": "admin"
    }
    
    selected_feature = st.sidebar.selectbox(
        "Escolha uma funcionalidade:",
        list(features.keys())
    )
    
    # Renderiza a funcionalidade selecionada
    feature_key = features[selected_feature]
    
    if feature_key == "analytics" and (meta or chat_history):
        if meta:
            create_biodiversity_metrics_dashboard(meta)
            generate_topic_analysis(meta)
        if chat_history:
            create_conversation_analytics(chat_history)
            create_dr_c_persona_metrics(chat_history)
    
    elif feature_key == "educational":
        create_educational_mode()
    
    elif feature_key == "timeline":
        create_interactive_timeline()
    
    elif feature_key == "calculator":
        create_impact_calculator()
    
    elif feature_key == "feedback":
        add_feedback_system()
    
    elif feature_key == "api":
        create_api_documentation()
    
    elif feature_key == "admin":
        create_admin_panel()
    
    else:
        st.info("Selecione uma funcionalidade avan√ßada no menu lateral.")

# ================== EXEMPLO DE USO ==================
if __name__ == "__main__":
    # Esta fun√ß√£o seria chamada na aplica√ß√£o principal
    # render_advanced_features(meta, st.session_state.chat_history) 'amaz√¥nica', 'amaz√¥nico'],
        'tecnologia': ['tecnologia', 'blockchain', 'intelig√™ncia', 'artificial']
    }
    
    # Conta ocorr√™ncias
    topic_counts = {}
    all_text = ' '.join([m.get('content', '').lower() for m in meta])
    
    for topic, keywords in biodiversity_keywords.items():
        count = sum(all_text.count(keyword) for keyword in keywords)
        topic_counts[topic] = count
    
    # Visualiza√ß√£o
    if topic_counts:
        df_topics = pd.DataFrame([
            {"T√≥pico": topic.title(), "Men√ß√µes": count}
            for topic, count in topic_counts.items()
        ])
        
        fig_bar = px.bar(
            df_topics.sort_values('Men√ß√µes', ascending=True),
            x='Men√ß√µes',
            y='T√≥pico',
            orientation='h',
            title="Frequ√™ncia de T√≥picos na Base de Conhecimento",
            color='Men√ß√µes',
            color_continuous_scale='Greens'
        )
        st.plotly_chart(fig_bar, use_container_width=True)

def create_conversation_analytics(chat_history):
    """Analytics das conversas com Dr_C"""
    if not chat_history:
        return
    
    st.subheader("üìà Analytics de Conversas")
    
    col1, col2 = st.columns(2)
    
    with col1:
        # Evolu√ß√£o temporal
        timestamps = [chat.get('timestamp', '') for chat in chat_history]
        questions = [len(chat.get('question', '').split()) for chat in chat_history]
        
        df_time = pd.DataFrame({
            'Conversa': range(1, len(chat_history) + 1),
            'Palavras_Pergunta': questions
        })
        
        fig_line = px.line(
            df_time,
            x='Conversa',
            y='Palavras_Pergunta',
            title="Complexidade das Perguntas ao Longo do Tempo",
            markers=True
        )
        st.plotly_chart(fig_line, use_container_width=True)
    
    with col2:
        # Qualidade das respostas (baseada no n√∫mero de fontes)
        source_counts = [len(chat.get('sources', [])) for chat in chat_history]
        
        df_quality = pd.DataFrame({
            'Conversa': range(1, len(chat_history) + 1),
            'Fontes_Utilizadas': source_counts
        })
        
        fig_quality = px.bar(
            df_quality,
            x='Conversa',
            y='Fontes_Utilizadas',
            title="N√∫mero de Fontes por Resposta",
            color='Fontes_Utilizadas',
            color_continuous_scale='Blues'
        )
        st.plotly_chart(fig_quality, use_container_width=True)

def export_conversation_report(chat_history, format_type="markdown"):
    """Exporta relat√≥rio da conversa"""
    if not chat_history:
        return None
    
    if format_type == "markdown":
        report = "# Relat√≥rio de Conversa com Dr_C\n\n"
        report += f"**Data:** {datetime.now().strftime('%d/%m/%Y %H:%M')}\n"
        report += f"**Total de Intera√ß√µes:** {len(chat_history)}\n\n"
        
        for i, chat in enumerate(chat_history, 1):
            report += f"## Intera√ß√£o {i} ({chat.get('timestamp', 'N/A')})\n\n"
            report += f"**Pergunta:** {chat.get('question', 'N/A')}\n\n"
            report += f"**Resposta do Dr_C:**\n{chat.get('answer', 'N/A')}\n\n"
            
            if chat.get('sources'):
                report += "**Fontes Utilizadas:**\n"
                for j, source in enumerate(chat['sources'], 1):
                    report += f"{j}. {source.get('source', 'N/A')}\n"
                report += "\n"
            
            report += "---\n\n"
        
        return report
    
    elif format_type == "json":
        return json.dumps(chat_history, indent=2, ensure_ascii=False)
    
    return None

def create_knowledge_gap_analysis(query_history, meta):
    """Identifica lacunas de conhecimento baseado nas perguntas"""
    if not query_history or not meta:
        return
    
    st.subheader("üîç An√°lise de Lacunas de Conhecimento")
    
    # Extrai palavras-chave das perguntas
    all_queries = ' '.join(query_history).lower()
    
    # Palavras comuns em perguntas sobre biodiversidade
    common_words = ['como', 'que', 'qual', 'por', 'onde', 'quando', 'quem']
    query_words = [word for word in all_queries.split() 
                   if len(word) > 3 and word not in common_words]
    
    # Conte√∫do dispon√≠vel
    all_content = ' '.join([m.get('content', '').lower() for m in meta])
    
    # Identifica palavras perguntadas que t√™m pouca cobertura
    gaps = []
    for word in set(query_words):
        content_count = all_content.count(word)
        query_count = all_queries.count(word)
        
        if query_count > 0 and content_count < 3:  # Threshold baixo
            gaps.append({
                'termo': word,
                'perguntas': query_count,
                'cobertura': content_count
            })
    
    if gaps:
        df_gaps = pd.DataFrame(gaps)
        st.write("**Temas com baixa cobertura na base de conhecimento:**")
        
        for _, row in df_gaps.head(10).iterrows():
            st.write(f"- **{row['termo']}**: {row['perguntas']} pergunta(s), {row['cobertura']} men√ß√£o(√µes)")

def create_dr_c_persona_metrics(chat_history):
    """M√©tricas sobre como o Dr_C est√° respondendo (tom, estilo)"""
    if not chat_history:
        return
    
    st.subheader("üé≠ An√°lise da Persona Dr_C")
    
    # Palavras-chave caracter√≠sticas do Dr_C
    persona_indicators = {
        'experi√™ncia_pessoal': ['minha', 'meu', 'vi', 'aprendi', 'presenciei'],
        'tom_pragm√°tico': ['pr√°tico', 'vi√°vel', 'econ√¥mico', 'lucro', 'rent√°vel'],
        'conserva√ß√£o': ['floresta', 'preservar', 'conservar', 'sustent√°vel'],
        'amaz√¥nia': ['amaz√¥nia',
